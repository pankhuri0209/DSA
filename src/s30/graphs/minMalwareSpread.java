package s30.graphs;

import java.util.Arrays;

public class minMalwareSpread {
    /**
     * Problem: Minimize Malware Spread
     *
     * Given: A graph and a list of initially infected nodes
     * Goal: Remove ONE node from initial to minimize total infected nodes
     *
     * Example Graph:
     *      0  1  2  3  4
     *   0 [1, 1, 0, 0, 0]
     *   1 [1, 1, 1, 0, 0]
     *   2 [0, 1, 1, 0, 0]
     *   3 [0, 0, 0, 1, 1]
     *   4 [0, 0, 0, 1, 1]
     *
     * Visual: 0 ←→ 1 ←→ 2        3 ←→ 4
     *        (Component 0)      (Component 1)
     *
     * initial = [0, 3]
     *
     * Strategy:
     * 1. Identify all connected components using DFS
     * 2. Count size of each component
     * 3. Count how many initial infected nodes are in each component
     * 4. Remove the node that uniquely infects the largest component
     */
    //TC= O(n^2) ; SC =O(n)
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // STEP 1: Color each connected component with DFS
        int n = graph.length;
        int[] colors= new int[n];
        int colorIndex=0;
        Arrays.fill(colors, -1);
        for (int i = 0; i < n; i++) {
            if (colors[i]==-1)
            {
                dfs(graph, i, colorIndex, colors);
                colorIndex++; //move to next color
            }
        }

        // After coloring: colors = [0, 0, 0, 1, 1]
        // Nodes 0,1,2 are in component 0
        // Nodes 3,4 are in component 1
        // colorId = 2 (total number of components)

        // STEP 2: Count how many nodes are in each component
        int[] componentSize= new int[colorIndex];

        for (int node=0; node<n;node++)
        {
            int componentId =  colors[node];
            componentSize[componentId]++;
        }
        // Example result: componentSize = [3, 2]
        // Component 0 has 3 nodes (0, 1, 2)
        // Component 1 has 2 nodes (3, 4)

        // STEP 3: Count how many INITIAL infected nodes are in each component
        int[] infectedNodes = new int[colorIndex];
        for (int node: initial)
        {
            int componentId =  colors[node];
            infectedNodes[componentId]++;
        }

        // STEP 4: Find which node to remove
        // Key insight: Only remove a node if it's the ONLY initial infected node
        // in its component. Otherwise, removing it won't help (other infected
        // nodes will still infect the component)

        int bestNode=Integer.MAX_VALUE;
        for (int node: initial)
        {
            int componentId =  colors[node];
            // Check if this node is the ONLY initial infected node in its component
            if (infectedNodes[componentId]==1)
            {
                // This node uniquely infects its component!
                // Removing it would save the entire component
                if (bestNode==Integer.MAX_VALUE)
                {
                    bestNode=node;
                } else if (componentSize[componentId] > componentSize[colors[bestNode]]) {
                    bestNode=node;
                    // Example: node 0's component has 3 nodes
                    //          node 3's component has 2 nodes
                    //          3 > 2, so prefer removing node 0
                } else if (componentSize[componentId] == componentSize[colors[bestNode]]) {
                    bestNode= Math.min(bestNode,node);
                }
            }
        }
        if (bestNode==Integer.MAX_VALUE)
        {
            for (int node: initial)
                 bestNode= Math.min(bestNode,node);
        }
        return bestNode;
    }
    // As the below function recursively works ; a component is formed
    private void dfs(int[][] graph, int currColor, int colorIndex, int[] colors) {
        // base case
        if (colors[currColor]!=-1){return;}

        //logic
        colors[currColor]=colorIndex;

        for (int neigh=0; neigh< graph.length; neigh++) {
            if (neigh==currColor){continue;} // skip ; for self node, same node

            // if there is an edge
            if (graph[currColor][neigh]==1 && colors[neigh]==-1){ // connected and unvisited
                dfs(graph, neigh, colorIndex, colors);
            }
        }

    }
}